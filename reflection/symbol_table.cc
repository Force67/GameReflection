// Copyright (C) Force67 <github.com/Force67>.
// For licensing information see LICENSE at the root of this distribution.
#include "symbol_table.h"
#include <cstdio>

namespace refl {

namespace {
FILE* MakeFile(std::string_view path) {
  FILE* file{};
#if defined(OS_WIN)
  fopen_s(&file, path.data(), "wb");
#else
  file = fopen(path.data(), "wb");
#endif
  return file;
}
}  // namespace

SymbolTable::SymbolTable(const std::string& json_name, const std::string& header_name)
    : json_name_(json_name), header_name_(header_name) {}

void SymbolTable::AddSymbol(const std::string& name, const std::string* signature) {
  storage_.emplace_back(std::move(name), signature ? std::move(*signature) : "");
}

void SymbolTable::ExportJson() {
  if (FILE* fptr = MakeFile(json_name_)) {
    fprintf(fptr, "{\"hooks\":[\n");
    for (Node& sym : storage_) {
      fprintf(fptr, "{\"name\":\"%s\", \"address\":0},\n", sym.name.c_str());
    }
    fprintf(fptr, "]}");
    fclose(fptr);
  }
}

void SymbolTable::ExportHookHeader() {
  if (FILE* fptr = MakeFile(header_name_)) {
    fprintf(fptr, "#pragma once\n\n//Autogenerated by gamerefr (c) Force67\n\n");
    // set up extern bindings
    for (Node& sym : storage_) {
      if (!sym.signature.empty()) {
        fprintf(fptr, "extern %s%s;\n", sym.name.c_str(), sym.signature.c_str());
      } else {
        fprintf(fptr, "extern %s;\n", sym.name.c_str());
      }
    }
    // set up overrides
    for (Node& sym : storage_) {
    }

    fclose(fptr);
  }
}
}  // namespace refl